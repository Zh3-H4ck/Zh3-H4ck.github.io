<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Codeql for Vulnerability Goapp - Zhe'BLog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Zhe"><meta name=description content="今天我们利用codeql分析下“cookie未启用httponly“这类的安全问题，由此加深自己对codeql的使用。"><meta name=generator content="Hugo 0.80.0 with theme even"><link rel=canonical href=https://Zh3-H4ck.github.io/post/codeql-for-vulnerability-goapp/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.8e26a09b7b99e8ec3a22900de69b02b568e23ace71d66ebfdb13fa655d365f1f.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Codeql for Vulnerability Goapp"><meta property="og:description" content="今天我们利用codeql分析下“cookie未启用httponly“这类的安全问题，由此加深自己对codeql的使用。"><meta property="og:type" content="article"><meta property="og:url" content="https://Zh3-H4ck.github.io/post/codeql-for-vulnerability-goapp/"><meta property="article:published_time" content="2020-10-28T10:46:52+08:00"><meta property="article:modified_time" content="2020-10-28T10:46:52+08:00"><meta itemprop=name content="Codeql for Vulnerability Goapp"><meta itemprop=description content="今天我们利用codeql分析下“cookie未启用httponly“这类的安全问题，由此加深自己对codeql的使用。"><meta itemprop=datePublished content="2020-10-28T10:46:52+08:00"><meta itemprop=dateModified content="2020-10-28T10:46:52+08:00"><meta itemprop=wordCount content="1922"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Codeql for Vulnerability Goapp"><meta name=twitter:description content="今天我们利用codeql分析下“cookie未启用httponly“这类的安全问题，由此加深自己对codeql的使用。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Zhe'Blog</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Zhe'Blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Codeql for Vulnerability Goapp</h1><div class=post-meta><span class=post-time>2020-10-28</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#序>序</a></li><li><a href=#审计对象与目的>审计对象与目的</a></li><li><a href=#确定source和sink>确定Source和Sink</a></li><li><a href=#taintconfig定义>TaintConfig定义</a></li><li><a href=#最终脚本>最终脚本</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><h3 id=序>序</h3><p>今天我们利用codeql分析下“cookie未启用httponly“这类的安全问题，由此加深自己对codeql的使用</p><p>分析go程序时必须额外下载<a href=https://github.com/github/codeql-go>codeql-go</a></p><h3 id=审计对象与目的>审计对象与目的</h3><p>审计对象我们用<a href=https://github.com/Snow-HardWolf/Vulnerability-goapp>Vulnerability-goapp</a>
因为该项目中的所有cookie均未设置http-only，没有对比性，所以我们先要对其修改。在一些cookie设置中添加上http-only，修改记录如下</p><p>pkg\admin\admin.go修改如下
<img src=assets/2020-10-28-11-09-33.png alt=admin.go></p><p>pkg\login\login.go修改如下
<img src=assets/2020-10-28-11-11-57.png alt=login.go></p><p>pkg\register\register.go修改如下
<img src=assets/2020-10-28-11-13-28.png alt=register.go></p><p>修改后记得重新生成一次database（如果需要覆盖旧的DATabase的话，则需要先删除旧的再生成新的</p><p>我们的目的就是通过codeql脚本来发现其中未设置httponly和设置了httponly的但httponly的值为false（一般不会这样，但保不齐有）的这样存在漏洞的点。</p><h3 id=确定source和sink>确定Source和Sink</h3><p>Sink很简单，设置Cookie时，需要用到http.SetCookie方法,而需要设置的Cookie值是这个函数的第二个参数，然后我们可以写出找到类似这样Sink的查询语句</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>import go
from DataFlow::Node sink
where exists(DataFlow::CallNode c |
      c.getTarget().hasQualifiedName(&#34;net/http&#34;, &#34;SetCookie&#34;) and c.getArgument(1) = sink
    )
select sink
</code></pre></td></tr></table></div></div><p>运行后可获得以下结果，点击任意条目都会跳转到复合要求的代码段下
<img src=assets/2020-10-28-16-46-46.png alt=2020-10-28-16-46-46></p><p>我们将其转换成一个Sink类，如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>private class Sink extends DataFlow::Node {
  Sink() {
    exists(DataFlow::CallNode c |
      c.getTarget().hasQualifiedName(&#34;net/http&#34;, &#34;SetCookie&#34;) and c.getArgument(1) = this
    )
  }
}
</code></pre></td></tr></table></div></div><p>这样之后我们通过将一个变量定义成Sink的话，就是指符合条件的所有代码片段，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>import go

private class Sink extends DataFlow::Node {
  Sink() {
    exists(DataFlow::CallNode c |
      c.getTarget().hasQualifiedName(&#34;net/http&#34;, &#34;SetCookie&#34;) and c.getArgument(1) = this
    )
  }
}

from Sink s
select s

</code></pre></td></tr></table></div></div><p>运行后会获得同样的结果</p><p>然后我们再来确定Source,从http.SetCookie方法接收的参数来看，实际第二个参数是接收一个Cookie的结构体
<img src=assets/2020-10-29-08-58-43.png alt=2020-10-29-08-58-43></p><p><img src=assets/2020-10-29-08-59-48.png alt=2020-10-29-08-59-48></p><p>所以我们先要找到这样一个结构体，我们可以先把项目中所有的结构体列出来
codeql-go中关于结构体的定义如下
<img src=assets/2020-10-29-09-02-45.png alt=2020-10-29-09-02-45></p><p>所以我们的查询脚本例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>import go

from StructLit source
select source

</code></pre></td></tr></table></div></div><p>也如我们预期的一样列出了所有的结构体
<img src=assets/2020-10-29-09-03-55.png alt=2020-10-29-09-03-55></p><p>然后接下来就是剔除其他不相干的内容,对类型做限制</p><p>关于hasQualifiedName方法，在各种Codeql-go中的各种类型都有相同的方法，定义如下，标记对象的是在属于哪个包，叫什么名。
<img src=assets/2020-10-29-09-10-24.png alt=2020-10-29-09-10-24></p><p>如果不确定的话，可以通过，getPackage和getName打印相关字段,例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>import go

from StructLit source
// where source.getType().hasQualifiedName(&#34;net/http&#34;, &#34;Cookie&#34;)
select source.getType().getPackage(), source.getType().getName()

</code></pre></td></tr></table></div></div><p>结果如下
<img src=assets/2020-10-29-09-13-43.png alt=2020-10-29-09-13-43></p><p>我们可以找到source定义，例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>import go

from StructLit source
where source.getType().hasQualifiedName(&#34;net/http&#34;, &#34;Cookie&#34;)
select source

</code></pre></td></tr></table></div></div><p><img src=assets/2020-10-29-09-06-54.png alt=2020-10-29-09-06-54>
同样转换成DataFlow::Node的子类</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>private class Source extends DataFlow::Node {
  Source() {
    exists(StructLit s | s.getType().hasQualifiedName(&#34;net/http&#34;, &#34;Cookie&#34;) and this.asExpr() = s)
  }
}
</code></pre></td></tr></table></div></div><h3 id=taintconfig定义>TaintConfig定义</h3><p>有了Source和Sink，简单定义TaintConfig，就能获得所有从Source到Sink的数据流</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>import go

private class Source extends DataFlow::Node {
  Source() {
    exists(StructLit s | s.getType().hasQualifiedName(&#34;net/http&#34;, &#34;Cookie&#34;) and this.asExpr() = s)
  }
}

private class Sink extends DataFlow::Node {
  Sink() {
    exists(DataFlow::CallNode c |
      c.getTarget().hasQualifiedName(&#34;net/http&#34;, &#34;SetCookie&#34;) and c.getArgument(1) = this
    )
  }
}

class Configuration extends TaintTracking::Configuration {
  Configuration() { this = &#34;HttpOnly&#34; }

  override predicate isSource(DataFlow::Node source) { source instanceof Source }

  override predicate isSink(DataFlow::Node sink) { sink instanceof Sink }
}

from Configuration cfg, DataFlow::PathNode source, DataFlow::PathNode sink
where cfg.hasFlowPath(source, sink)
select source, sink

</code></pre></td></tr></table></div></div><p>结果如下：
<img src=assets/2020-10-29-09-43-44.png alt=2020-10-29-09-43-44></p><p>但是还没完，我们并没有将设置了httponly=true的部分给剔除。所以需要增加限定，就是将给HttpOnly字段设置了true的数据流，从结果中剔除。</p><p>我们可以 CodeQL 提供的 TaintTracking::isSanitizer，来过滤无害节点：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>override predicate isSanitizer(DataFlow::Node node) {
    exists(Write w, Field f, DataFlow::Node rhs |
      f.hasQualifiedName(&#34;net/http&#34;, &#34;Cookie&#34;, &#34;HttpOnly&#34;) and
      w.writesField(node, f, rhs) and
      rhs.getBoolValue() = true
    )
  }
</code></pre></td></tr></table></div></div><p>运行结果如下，有一处地方需要注意
<img src=assets/2020-10-29-14-18-58.png alt=2020-10-29-14-18-58>
红框中实际有对HttpOnly进行设置，但我们的脚本并不能识别这样的一个数据流。后面试了各种方法，最终找到一种解决方式，将isSanitizer修改成以下内容</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>override predicate isSanitizer(DataFlow::Node node) {
    exists(Write w, Field f, DataFlow::Node n, DataFlow::Node rhs |
      f.hasQualifiedName(&#34;net/http&#34;, &#34;Cookie&#34;, &#34;HttpOnly&#34;) and
      w.writesField(n, f, rhs) and
      rhs.getBoolValue() = true and
      node = n.getAPredecessor*()n
    )
  }
</code></pre></td></tr></table></div></div><p>其中<code>node=n.getAPredecessor*()</code>是说node是n的前置数据流节点，数据可以在0个或多个步骤中从node流到n。</p><h3 id=最终脚本>最终脚本</h3><p>加上一些信息，模仿官方的示例，最终脚本如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>/**
 * @name Cookie未设置httponly
 * @description Cookies包含一个HTTPOnly的设置选项，可以使此cookie不能被js读取，而只能用于HTTP请求。
 * @kind path-problem
 * @problem.severity error
 * @precision low
 * @id go/Cookie-not-set-httponly
 * @tags security
 */

import go
import DataFlow::PathGraph

private class Source extends DataFlow::Node {
  Source() {
    exists(StructLit s | s.getType().hasQualifiedName(&#34;net/http&#34;, &#34;Cookie&#34;) and this.asExpr() = s)
  }
}

private class Sink extends DataFlow::Node {
  Sink() {
    exists(DataFlow::CallNode c |
      c.getTarget().hasQualifiedName(&#34;net/http&#34;, &#34;SetCookie&#34;) and c.getArgument(1) = this
    )
  }
}

class Configuration extends TaintTracking::Configuration {
  Configuration() { this = &#34;HttpOnly&#34; }

  override predicate isSource(DataFlow::Node source) { source instanceof Source }

  override predicate isSink(DataFlow::Node sink) { sink instanceof Sink }

  override predicate isSanitizer(DataFlow::Node node) {
    exists(Write w, Field f, DataFlow::Node n, DataFlow::Node rhs |
      f.hasQualifiedName(&#34;net/http&#34;, &#34;Cookie&#34;, &#34;HttpOnly&#34;) and
      w.writesField(n, f, rhs) and
      rhs.getBoolValue() = true and
      node = n.getAPredecessor*()
    )
  }
}

from Configuration cfg, DataFlow::PathNode source, DataFlow::PathNode sink
where cfg.hasFlowPath(source, sink)
select sink.getNode(), source, sink, &#34;Cookie-not-set-httponly in $@.&#34;, source.getNode(), &#34;here&#34;


</code></pre></td></tr></table></div></div><p>最终筛选出存在问题的内容。
<img src=assets/2020-10-29-14-55-56.png alt=2020-10-29-14-55-56></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Zhe</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2020-10-28</span></p></div><footer class=post-footer><nav class=post-nav><a class=prev href=/post/2020justctf/><i class="iconfont icon-left"></i><span class="prev-text nav-default">2020justCTF</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/codeql-go/><span class="next-text nav-default">Codeql审计goDemo</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=https://zh3-h4ck.github.io class="iconfont icon-github" title=github></a><a href=https://Zh3-H4ck.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2021<span class=heart><i class="iconfont icon-heart"></i></span><span>Zhe</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js></script></body></html>